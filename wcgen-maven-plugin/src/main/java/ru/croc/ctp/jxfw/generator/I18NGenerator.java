package ru.croc.ctp.jxfw.generator;

import org.apache.commons.lang.StringEscapeUtils;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.ENamedElement;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.croc.ctp.jxfw.metamodel.impl.XfwLocalizableAdapterFactory;
import ru.croc.ctp.jxfw.metamodel.runtime.XfwLocalizable;
import ru.croc.ctp.jxfw.mojo.EcoreProcessor;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

/**
 * Процессор для генерации i18n файлов по данным из ecore модели.
 *
 * @see ru.croc.ctp.jxfw.mojo.GenerateI18NMojo
 */
public class I18NGenerator extends EcoreProcessor {
    private static final Logger logger = LoggerFactory.getLogger(I18NGenerator.class);



    private Map<String, File> localeFiles = new HashMap<>();

    /**
     * Конструктор.
     *
     * @param sourceDirectory - папка с метамоделью.
     * @param outputDirectory - папка куда генерируется файлы i18n.
     */
    public I18NGenerator(File sourceDirectory, File outputDirectory) {
        super(sourceDirectory, outputDirectory);
    }


    @Override
    protected void createFiles() {
        for (String lang : xfwModel.getAvailableLanguages()) {
            File file = Paths.get(outputDirectory.getPath(), lang, "resources.js").toFile();
            localeFiles.put(lang, file);
            checkFileAutogenerated(file);
        }
    }

    @Override
    protected void generateFiles() {
        for (Entry<String, File> locale : localeFiles.entrySet()) {

            VelocityContext vc = new VelocityContext();

            vc.put("lang", locale.getKey());
            vc.put("context", this);

            try (Writer w = new OutputStreamWriter(new FileOutputStream(
                    locale.getValue()), StandardCharsets.UTF_8)) {
                Template vt = ve.getTemplate("resources.vm");
                vt.merge(vc, w);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

            logger.info("Generated file: {}", locale.getValue());

        }

    }

    /**
     * Получить значение label для определенного класса на определенным языке.
     *
     * @param element - элемент ecore модели, для которого получаем label
     * @param lang    - язык на котором необходимо получить label
     * @return значение label
     */
    @SuppressWarnings("unused")
    public String getLocalizedTypeName(EClassifier element, String lang) {

        String defaultLabel = toFirstUpper(element.getName());
        XfwLocalizable localizable = (XfwLocalizable) XfwLocalizableAdapterFactory.INSTANCE.adapt(element, XfwLocalizable.class);
        String label = localizable != null
                ?  StringEscapeUtils.escapeJavaScript(localizable.getLocalizedTypeName(lang)) : null;
        return label == null ? defaultLabel : label;
    }

    /**
     * Получить значение label для определенного элемента определенного класса на определенным языке.
     *
     * @param element - класс
     * @param field   - элемент ecore модели, для которого получаем label
     * @param lang    - язык на котором необходимо получить label
     * @return значение label
     */
    @SuppressWarnings("unused")
    public String getLocalizedFieldName(EClassifier element, ENamedElement field, String lang) {

        String defaultLabel = toFirstUpper(field.getName());
        XfwLocalizable localizable = (XfwLocalizable) XfwLocalizableAdapterFactory.INSTANCE.adapt(element, XfwLocalizable.class);
        String label = localizable != null
                ? StringEscapeUtils.escapeJavaScript(localizable.getLocalizedFieldName(field.getName(), lang)) : null;
        return label == null ? defaultLabel : label;
    }

}
