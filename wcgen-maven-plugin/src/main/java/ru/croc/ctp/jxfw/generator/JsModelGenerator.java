package ru.croc.ctp.jxfw.generator;

import static org.eclipse.emf.ecore.EcorePackage.Literals.ESTRING;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.ATTRIBUTE_PROPS_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.COLUMN_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.CONTENT_TYPE_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.DIGITS_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.MAX_EXCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.MAX_INCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.MAX_VALUE_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.MIN_EXCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.MIN_INCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.MIN_VALUE_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.PATTERN_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.RELATION_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.SIZE_VALIDATED_FIELD_ANNOTATION_SOURCE;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.XFW_OBJECT_ANNOTATION;
import static ru.croc.ctp.jxfw.metamodel.XFWConstants.XFW_TRANSIENT_ANNOTATION;

import org.apache.commons.lang3.StringUtils;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.eclipse.emf.common.util.EMap;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.croc.ctp.jxfw.core.domain.DomainObject;
import ru.croc.ctp.jxfw.core.generator.meta.XFWObject;
import ru.croc.ctp.jxfw.metamodel.XFWAttribute;
import ru.croc.ctp.jxfw.metamodel.XFWClass;
import ru.croc.ctp.jxfw.metamodel.XFWConstants;
import ru.croc.ctp.jxfw.metamodel.XFWMMFactory;
import ru.croc.ctp.jxfw.metamodel.impl.ModelHelper;
import ru.croc.ctp.jxfw.mojo.EcoreProcessor;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import javax.persistence.Lob;

/**
 * Генератор model.js из EcoreModel'и.
 */
public class JsModelGenerator extends EcoreProcessor {

    private static final Logger logger = LoggerFactory.getLogger(JsModelGenerator.class);

    private static final String COMPLEX_KEY_ORDER = "complexKeyOrder"; //TODO Убрать копипаст из EcoreGenerator

    private File modelFile;

    private final String jsModelMetaFileName;

    /**
     * Конструктор.
     *
     * @param sourceDirectory - исходная папка с Ecore моделью
     * @param outputDirectory - выходная папка куда кладется model.js
     * @param jsModelMetaFileName имя фалы модели
     */
    public JsModelGenerator(File sourceDirectory, File outputDirectory, String jsModelMetaFileName) {
        super(sourceDirectory, outputDirectory);
        this.jsModelMetaFileName = jsModelMetaFileName;
    }

    @Override
    protected void createFiles() {
        modelFile = Paths.get(outputDirectory.getPath(), jsModelMetaFileName).toFile();
        checkFileAutogenerated(modelFile);
    }

    @Override
    protected void generateFiles() {
        VelocityContext vc = new VelocityContext();

        vc.put("context", this);

        try (Writer w = new OutputStreamWriter(new FileOutputStream(modelFile),
                StandardCharsets.UTF_8)) {
            Template vt = ve.getTemplate("model.vm");
            vt.merge(vc, w);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        logger.info("Generated file: {}", modelFile);
    }

    @Override
    public List<XFWClass> getEClasses() {
        List<XFWClass> classes = super.getEClasses();

        classes = removeDuplicates(classes);

        //Добавляется класс FiledIn, если в модели есть CMIS-сущности

        boolean cmisModuleFound = false;
        for (EClass c : classes) {
            XFWClass xfwClass = (XFWClass) c;
            if (xfwClass.getPersistenceModule().contains("CMIS")) {
                cmisModuleFound = true;
                break;
            }
        }

        if (cmisModuleFound) {
            XFWMMFactory factory = XFWMMFactory.eINSTANCE;
            XFWClass filedIn = factory.createXFWClass();
            filedIn.setName("FiledIn");
            filedIn.setInstanceClassName("ru.croc.ctp.jxfw.cmis.FiledIn");
            XFWAttribute attr = factory.createXFWAttribute();
            attr.setName("folderId");
            attr.setEType(EcorePackage.eINSTANCE.getEString());
            filedIn.getEStructuralFeatures().add(attr);
            attr = factory.createXFWAttribute();
            attr.setName("objectId");
            attr.setEType(EcorePackage.eINSTANCE.getEString());
            filedIn.getEStructuralFeatures().add(attr);
            classes.add(filedIn);
        }

        return classes;
    }

    /**
     * Возвращает часть JSON описания поля.
     *
     * @param field - поле
     * @return строка, часть JSON описания
     */
    @SuppressWarnings("unused")
    public String getTypeParams(EStructuralFeature field) {
        StringBuilder sb = new StringBuilder();
        if (field.isUnsettable()) {
            sb.append(", nullable: true");
        } else {
            sb.append(", nullable: false");
        }
        if (!field.isChangeable()) {
            sb.append(", readOnly: true");
        }
        appendDefaultValue(field, sb); // если установлено дефолтное значение
        if (field instanceof EReference && !isComplexTypeField(field)) {
            EReference ref = (EReference) field;
            sb.append(", ref: \"").append(ref.getEType().getName())
                    .append("\"");
            if (ref.getEOpposite() != null) {
                sb.append(", opposite: \"")
                        .append(ref.getEOpposite().getName()).append("\"");
            }
            if (ref.getUpperBound() != 1) {
                sb.append(", many: true");
            }
            if (ref.getEAnnotation(RELATION_ANNOTATION_SOURCE.getUri()) != null) {
                final EAnnotation relAnnotation = ref.getEAnnotation(RELATION_ANNOTATION_SOURCE.getUri());
                final EMap<String, String> details = relAnnotation.getDetails();
                final String lazyload = details.get("lazyLoad");
                if (Boolean.parseBoolean(lazyload)) {
                    sb.append(", lazyLoad: ").append(lazyload);
                }
            }
        } else if (field.getEType() instanceof EEnum) {
            sb.append(", ref: \"").append(field.getEType().getName())
                    .append("\"");
        } else if (field.getEType().equals(ESTRING)) {
            EAnnotation columnAnnotation = field.getEAnnotation(SIZE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
            if (columnAnnotation != null) {
                String minLen = columnAnnotation.getDetails().get("minLen");
                sb.append(", minLen: ").append(minLen);
            }
            if (columnAnnotation == null) {
                columnAnnotation = field.getEAnnotation(COLUMN_ANNOTATION_SOURCE.getUri());
            }
            if (!isLobField(field) && columnAnnotation != null) {
                String length = columnAnnotation.getDetails().get("length");
                if (length != null) {
                    sb.append(", maxLen: ").append(length);
                }
            }
        }
        return sb.toString();
    }

    /**
     * дефолтное значение.
     *
     * @param field - поле
     * @param sb    - билдер для получения результата
     */
    private void appendDefaultValue(EStructuralFeature field, StringBuilder sb) {
        if (field.getDefaultValueLiteral() != null) {
            String defaultValueLiteral = field.getDefaultValueLiteral();
            String type = getTypeName(field);
            if (type.equals("enum")) {
                List<String> items = Arrays.asList(defaultValueLiteral.split("\\s*,\\s*"));
                if (items.size() > 0) {
                    Integer val = 0;
                    for (String item : items) {
                        EEnumLiteral literal = ((EEnum) field.getEType()).getEEnumLiteral(item.trim());
                        if (literal == null) {
                            throw new IllegalArgumentException("Failed to evaluate @XFWDefaultValue attribute = "
                                    + defaultValueLiteral
                                    + "for field " + field.getName());
                        } else {
                            val = val | literal.getValue();
                        }
                    }

                    sb.append(", init: ").append(val).append("");
                }
            } else if (isNumericOrBoolean(type)) {
                sb.append(", init: ").append(defaultValueLiteral).append("");
            } else {
                sb.append(", init: \"").append(defaultValueLiteral).append("\"");
            }
        }
    }

    /**
     * Возвращает простое имя типа поля.
     *
     * @param field - поле
     * @return тип
     */
    @SuppressWarnings({"WeakerAccess"}) //Вызывается из model.vm
    public String getTypeName(EStructuralFeature field) {
        if (field instanceof EReference && !isComplexTypeField(field)) {
            return "object";
        }
        switch (field.getEType().getName()) {
            case "EString":
                if (isLobField(field)) {
                    return "text";
                }
                final EAnnotation annotation = field.getEAnnotation(COLUMN_ANNOTATION_SOURCE.getUri());
                if (annotation != null
                        && annotation.getDetails() != null
                        && annotation.getDetails().get("length") != null
                        && Integer.valueOf(annotation.getDetails().get("length")) > 255) {
                    return "text";
                } else {
                    return "string";
                }
            case "EShort":
            case "EShortObject":
                return "i2";
            case "EInt":
            case "EIntegerObject":
                return "i4";
            case "ELong":
            case "ELongObject":
            case "EBigInteger":
                return "i8";
            case "EBoolean":
            case "EBooleanObject":
                return "boolean";
            case "LocalDateTime":
            case "LocalDateTime_Java7":
                return "dateTime";
            case "LocalDate":
            case "LocalDate_Java7":
                return "date";
            case "LocalTime":
            case "LocalTime_Java7":
                return "time";
            case "EFloat":
            case "EFloatObject":
            case "EDouble":
            case "EDoubleObject":
                return "double";
            case "EBigDecimal":
                return "decimal";
            case "EByte":
            case "EByteObject":
                return "byte";
            case "Blob":
                return "binary";
            case "ZonedDateTime":
            case "ZonedDateTime_Java7":
                return "dateTimeTz";
            case "Duration":
            case "Duration_Java7":
                return "timeSpan";
            case "EEnumerator":
                return "enum";
            case "UUID":
                return "uuid";
            default:
                if (field.getEType() instanceof EEnum) {
                    return "enum";
                }
                if (isComplexTypeField(field)) {
                    return "complex";
                }
                return "???";
        }
    }

    private boolean isLobField(EStructuralFeature field) {
        return field.getEAnnotation(
                XFWConstants.getUri(Lob.class.getSimpleName())) != null;
    }

    /**
     * * Проверка поля на признак перечисления.
     *
     * @param field - поле
     * @return значение boolean
     */
    @SuppressWarnings("unused")
    public boolean isEnum(EStructuralFeature field) {
        return field.getEType() instanceof EEnum;
    }


    private boolean isNumericOrBoolean(String type) {
        return type.equals("enum") || type.equals("i4") || type.equals("i8")
                || type.equals("double") || type.equals("boolean")
                || type.equals("decimal") || type.equals("byte");
    }

    /**
     * Проверка поля на признак комплексного типа.
     *
     * @param field - поле
     * @return значение boolean
     */
    @SuppressWarnings("WeakerAccess") //Вызывается из model.vm
    public boolean isComplexTypeField(EStructuralFeature field) {
        return ModelHelper.isComplexType(field);
    }


    /**
     * Проверка класса на признак комплексного типа.
     *
     * @param clazz - проверяемый класс из Ecore модели
     * @return значение boolean
     */
    @SuppressWarnings("unused")
    public boolean isComplexType(EClass clazz) {
        return clazz instanceof XFWClass && ((XFWClass) clazz).isComplexType();
    }

    /**
     * Часть JSON описания для комплексного типа.
     *
     * @param field - поле
     * @return Часть JSON описания
     */
    @SuppressWarnings("unused")
    public String getComplexTypeNameField(EStructuralFeature field) {
        if (isComplexTypeField(field)) {
            final String simpleClassName = field.getEType().getName();
            return " , ref: \"" + simpleClassName + "\"";
        }
        return "";
    }

    /**
     * если в аннотации поля указана информация о порядке этого поля в комплексном ключе
     * то надо ее добавить в js модель.
     *
     * @param field - поле
     * @return - комплексный тип или нет
     */
    @SuppressWarnings("unused")
    public String getComplexKeyFieldInfo(EStructuralFeature field) {
        EAnnotation annotation = field.getEAnnotation(ATTRIBUTE_PROPS_ANNOTATION_SOURCE.getUri());
        if (annotation == null || annotation.getDetails() == null) {
            return "";
        }
        String ord = annotation.getDetails().get(COMPLEX_KEY_ORDER);
        if (ord != null && ord.length() > 0) {
            return ", " + COMPLEX_KEY_ORDER + ": " + ord;
        }
        return "";
    }


    /**
     * Проверка - является ли тип поля приводимым к DomainObject.
     *
     * @param field - проверяемое поле
     * @return boolen значение
     * @see DomainObject
     */
    @SuppressWarnings("unused")
    public Boolean isFieldTypeAssianbleToDomainObject(EStructuralFeature field) {
        return field.getEType() instanceof XFWClass;
    }

    /**
     * Проверка класса на признак "абстрактный класс".
     *
     * @param clazz - проверяемый класс
     * @return boolean значение
     */
    @SuppressWarnings("unused")
    public Boolean isAbstract(EClass clazz) {
        return clazz instanceof XFWClass && clazz.isAbstract();
    }


    /**
     * Есть два разных transient объекта, один является temp сущностью с точки зрения WC,
     * другой для WC выглядит как обычный доменный объект, но вырезается из UoW при соранении на клиенте.
     * Этот метод проверяет принадлежность класса ко второму типу объектов.
     *
     * @param clazz - класс ecore-модели
     * @return да или нет
     */
    @SuppressWarnings("unused")
    public boolean isTransientXfwObject(EClass clazz) {
        if (!(clazz instanceof XFWClass)) {
            return false;
        }
        final XFWClass xfwClass = ((XFWClass) clazz);
        if (!xfwClass.isTransientType()) {
            return false;
        }
        try {
            final boolean defaultTemp = Boolean
                    .parseBoolean(XFWObject.class.getDeclaredMethod("temp").getDefaultValue().toString());
            final EAnnotation eAnnotation = xfwClass.getEAnnotation(XFW_OBJECT_ANNOTATION.getUri());
            return eAnnotation != null && eAnnotation.getDetails().get("temp") != null
                    ? Boolean.parseBoolean(eAnnotation.getDetails().get("temp")) : defaultTemp;
        } catch (Exception e) {
            logger.warn("Непредвиденная проблема с аннотацией " + XFWObject.class.getTypeName(), e);
        }
        return true;
    }

    /**
     * Проверяет является ли поле временным для фасада.
     * @param field поле
     * @return true/false.
     */
    public boolean isTransientField(EStructuralFeature field) {
        final EAnnotation xfwTransient = field.getEAnnotation(XFW_TRANSIENT_ANNOTATION.getUri());
        if (xfwTransient == null) {
            return false;
        }
        String tempStr = xfwTransient.getDetails().get("temp");
        return tempStr == null ? false : Boolean.parseBoolean(tempStr);
    }


    /**
     * Вернуть contentType для поля.
     *
     * @param field - проверяемое поле
     * @return значение contentType из аннотации
     */
    @SuppressWarnings("unused")
    public String getContentType(EStructuralFeature field) {
        String contentType = "";
        EAnnotation annotation = field.getEAnnotation(CONTENT_TYPE_ANNOTATION_SOURCE.getUri());
        if (annotation != null && annotation.getDetails() != null) {
            contentType = annotation.getDetails().get("value");
        }
        return StringUtils.isEmpty(contentType) ? null : contentType;
    }

    /**
     * Вернуть acceptFileTypes для поля.
     *
     * @param field - проверяемое поле
     * @return значение acceptFileTypes из аннотации
     */
    @SuppressWarnings("unused")
    public String getAcceptFileTypes(EStructuralFeature field) {
        String acceptFileTypes = "";
        EAnnotation annotation = field.getEAnnotation(CONTENT_TYPE_ANNOTATION_SOURCE.getUri());
        if (annotation != null && annotation.getDetails() != null) {
            acceptFileTypes = annotation.getDetails().get("acceptFileTypes");
        }
        return StringUtils.isEmpty(acceptFileTypes) ? null : acceptFileTypes;
    }


    /**
     * Получить значение isFlags из Enum в Ecore модели.
     *
     * @param ecoreEnum - enum из модели
     * @return boolean значение
     */
    @SuppressWarnings("unused")
    public Boolean getEnumFlags(EEnum ecoreEnum) {
        return xfwModel.getAll(XFWClass.class).stream().flatMap(xfwClass ->
                xfwClass.getEAllStructuralFeatures().stream())
                .filter(eStructuralFeature ->
                        eStructuralFeature.isMany() && eStructuralFeature.getEType().equals(ecoreEnum))
                .findAny().isPresent();
    }

    /**
     * Получение всей валидационной модели.
     *
     * @param feature - описание поля из ecore модели
     * @return строка с описанием модели
     */
    @SuppressWarnings("unused")
    public String printFacetsInformation(EStructuralFeature feature) {
        final StringBuilder out = new StringBuilder();

        if (hasPatternAnnotation(feature)) {
            final String regexp = getPatternRegexp(feature);
            final String flags = getPatternFlags(feature);
            final String message = getPatternMessage(feature);
            out.append(", ").append("pattern: /").append(regexp).append("/")
                    .append(flags).append(", ").append("patternMsg: \"").append(message).append("\"");
        }

        if (hasMinInclusiveAnnotation(feature)) {
            out.append(", ").append(" minInclusive: \"").append(getMinInclusiveValue(feature)).append("\"");
        }

        if (hasMinExclusiveAnnotation(feature)) {
            out.append(", ").append(" minExclusive: \"").append(getMinExclusiveValue(feature)).append("\"");
        }

        if (hasMaxInclusiveAnnotation(feature)) {
            out.append(", ").append(" maxInclusive: \"").append(getMaxInclusiveValue(feature)).append("\"");
        }

        if (hasMaxExclusiveAnnotation(feature)) {
            out.append(", ").append(" maxExclusive: \"").append(getMaxExclusiveValue(feature)).append("\"");
        }

        if (hasMaxValueAnnotation(feature)) {
            out.append(", ").append(" maxValue: \"").append(getMaxValue(feature)).append("\"");
        }

        if (hasMinValueAnnotation(feature)) {
            out.append(", ").append(" minValue: \"").append(getMinValue(feature)).append("\"");
        }

        if (hasDigitsAnnotation(feature)) {
            out.append(getFractionsAndTotalDigits(feature));
        }

        if (",".equals(out.toString())) {
            return "";
        }

        return out.toString();
    }

    /**
     * Метод для проверки помечено ли поле аннотацией @Pattern в модели.
     *
     * @param sf - поле для которого требуется проверить наличие аннотации @Pattern в модели
     * @return true или false
     */
    private boolean hasPatternAnnotation(EStructuralFeature sf) {
        final EAnnotation patternAnnotation = sf.getEAnnotation(PATTERN_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return patternAnnotation != null;
    }

    /**
     * Метод для получения RegExp из аннотации @Pattern в модели.
     *
     * @param sf - поле для которого требуется вернуть RegExp из аннотации @Pattern в модели
     * @return регулярное выражение из аннотации
     */
    private String getPatternRegexp(EStructuralFeature sf) {
        final EAnnotation patternAnnotation = sf.getEAnnotation(PATTERN_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (patternAnnotation != null) {
            return patternAnnotation.getDetails().get("regexp");
        }
        return "";
    }

    /**
     * Метод для получения flags из аннотации @Pattern в модели.
     *
     * @param sf - поле для которого требуется вернуть flags из аннотации @Pattern в модели
     * @return флаги в виде строки из аннотации
     */
    private String getPatternFlags(EStructuralFeature sf) {
        final EAnnotation patternAnnotation = sf.getEAnnotation(PATTERN_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (patternAnnotation != null) {
            return patternAnnotation.getDetails().get("flags");
        }
        return "";
    }

    /**
     * Метод для получения message из аннотации @Pattern в модели.
     *
     * @param sf - поле для которого требуется вернуть message из аннотации @Pattern в модели
     * @return сообщение из аннотации
     */
    private String getPatternMessage(EStructuralFeature sf) {
        final EAnnotation patternAnnotation = sf.getEAnnotation(PATTERN_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (patternAnnotation != null) {
            return patternAnnotation.getDetails().get("message");
        }
        return "";
    }

    private boolean hasMinInclusiveAnnotation(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MIN_INCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return annotation != null;
    }

    private String getMinInclusiveValue(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MIN_INCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (annotation != null) {
            return annotation.getDetails().get("value");
        }
        return "";
    }

    private boolean hasMinExclusiveAnnotation(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MIN_EXCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return annotation != null;
    }

    private String getMinExclusiveValue(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MIN_EXCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (annotation != null) {
            return annotation.getDetails().get("value");
        }
        return "";
    }

    private boolean hasMaxInclusiveAnnotation(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MAX_INCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return annotation != null;
    }

    private String getMaxInclusiveValue(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MAX_INCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (annotation != null) {
            return annotation.getDetails().get("value");
        }
        return "";
    }

    private boolean hasMaxExclusiveAnnotation(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MAX_EXCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return annotation != null;
    }

    private String getMaxExclusiveValue(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MAX_EXCLUSIVE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (annotation != null) {
            return annotation.getDetails().get("value");
        }
        return "";
    }

    private boolean hasMaxValueAnnotation(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MAX_VALUE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return annotation != null;
    }

    private String getMaxValue(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MAX_VALUE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (annotation != null) {
            return annotation.getDetails().get("value");
        }
        return "";
    }

    private boolean hasMinValueAnnotation(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MIN_VALUE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return annotation != null;
    }

    private String getMinValue(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(MIN_VALUE_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (annotation != null) {
            return annotation.getDetails().get("value");
        }
        return "";
    }

    private boolean hasDigitsAnnotation(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(DIGITS_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        return annotation != null;
    }

    private String getFractionsAndTotalDigits(EStructuralFeature sf) {
        final EAnnotation annotation = sf.getEAnnotation(DIGITS_VALIDATED_FIELD_ANNOTATION_SOURCE.getUri());
        if (annotation != null) {
            String totalDigits = annotation.getDetails().get("integer");
            String fractionDigits = annotation.getDetails().get("fraction");
            return ", " + "totalDigits: " + totalDigits
                    + ", " + "fractionDigits: " + fractionDigits;
        }
        return "";
    }

}
