package ru.croc.ctp.jxfw.mojo;

import org.apache.velocity.app.VelocityEngine;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.croc.ctp.jxfw.metamodel.XFWClass;
import ru.croc.ctp.jxfw.metamodel.XFWConstants;
import ru.croc.ctp.jxfw.metamodel.XFWModel;
import ru.croc.ctp.jxfw.metamodel.impl.XFWModelImpl;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

/**
 * Процессор для преобразования ecore модели.
 *
 * @since 1.0
 */
public abstract class EcoreProcessor {

    private static final Logger logger = LoggerFactory.getLogger(EcoreProcessor.class);

    private static final String GENERATED_COMMENT_OLD_STYLE = "//This file has been generated and should not be edited by hand";
    private static final String GENERATED_COMMENT_NEW_STYLE = "File was generated by CROC jXFW";

    /**
     * выходная папка куда кладется продукт преобразования.
     */
    protected File outputDirectory;

    /**
     * Шаблонизатор velocity.
     */
    protected VelocityEngine ve;

    private File sourceDirectory = null;

    protected XFWModel xfwModel;

    private boolean loaded = false;

    /**
     * @param sourceDirectory - исходная папка с Ecore моделью
     * @param outputDirectory - выходная папка куда кладется продукт преобразования.
     */
    public EcoreProcessor(File sourceDirectory, File outputDirectory) {
        if (!sourceDirectory.exists()) {
            logger.warn("Source directory doesn't exist: {}", sourceDirectory.getAbsolutePath());
        } else {
            this.sourceDirectory = sourceDirectory;
            xfwModel = new XFWModelImpl(this.sourceDirectory.toPath());
        }
        this.outputDirectory = outputDirectory;

        logger.debug("Source directory {}", sourceDirectory);
    }


    /**
     * Запустить процесс.
     */
    public void process() {
        if (sourceDirectory == null) {
            //конструктор уже записал предупреждение в лог
            return;
        }
        initialize();

        createFiles();

        generateFiles();
    }

    private void initialize() {
        if (!loaded) {

            xfwModel.getAll(EClassifier.class);

            Properties props = new Properties();

            URL url = this.getClass().getClassLoader().getResource("velocity.properties");

            if (url == null) {
                url = Thread.currentThread().getContextClassLoader().getResource("velocity.properties");
            }

            try {
                if (url != null) {
                    props.load(url.openStream());
                } else {
                    throw new IllegalStateException("Failed to load velocity.properties");
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

            ve = new VelocityEngine(props);
            ve.init();

            loaded = true;
        }
    }

    /**
     * Создать выходные файлы после проебразования.
     */
    protected abstract void createFiles();

    /**
     * Сгенерировать выходные файлы после проебразования.
     */
    protected abstract void generateFiles();

    /**
     * @return список всех классификаторов из всех пакетов.
     */
    @SuppressWarnings("unused")
    public Iterable<EClassifier> getEClassifiers() {
        // Датасорсы не добавляем, т.к. они не участвуют ни в создании клиентской модели,
        // ни в создании локализованных ресурсов.
        Set<EClassifier> result = new HashSet<>();
        result.addAll(xfwModel.getAll(XFWClass.class));
        result.addAll(xfwModel.getAll(EEnum.class));
        return result;
    }

    /**
     * @return список всех энумераторов из всех пакетов.
     */
    @SuppressWarnings("unused")
    public Iterable<EEnum> getEEnums() {
        List<EEnum> enums = new ArrayList<>();
        xfwModel.getAll(EEnum.class)
                .forEach(candidate -> {
                    // так мы избежим дублирования Enum' ов в js модели TERRA-110
                    if (enums.stream().filter(e -> e.getName().equals(candidate.getName())).count() < 1) {
                        enums.add(candidate);
                    }
                });
        return enums;
    }

    /**
     * @return список всех классов из всех пакетов.
     */
    public List<XFWClass> getEClasses() {
        initialize();
        return xfwModel.getAll(XFWClass.class).stream()
                .filter(c -> !c.isComplexType())
                .filter(cls -> cls.getEAnnotation(XFWConstants.SERVER_ONLY_ANNOTATION.getUri()) == null)
                .collect(Collectors.toList());
    }

    /**
     * Возвращает фильтр для полей, которые должны быть исключены из списка.
     *
     * @return фильтр
     */
    @SuppressWarnings("WeakerAccess") //Вызывается в model.vm
    public Predicate<EStructuralFeature> excludeFieldsFilter() {
        return f -> f.getEAnnotation(XFWConstants.SERVER_ONLY_ANNOTATION.getUri()) != null;
    }

    /**
     * @return список всех комплексных типов из всех пакетов.
     */
    @SuppressWarnings("unused")
    public Iterable<EClass> getEComplexTypeClasses() {
        return xfwModel.getAll(XFWClass.class).stream()
                .filter(XFWClass::isComplexType)
                .collect(Collectors.toList());
    }

    /**
     * Список всех элементов из классификатора.
     *
     * @param classifier - классификатор
     * @return Список всех элементов из классификатора.Список всех элементов из классификатора.
     */
    @SuppressWarnings("unused") //Вызывается в resources.vm
    public Iterable<? extends ENamedElement> getElements(EClassifier classifier) {
        if (classifier instanceof XFWClass) {
            return StreamSupport
                    .stream(((XFWClass) classifier).getOwnAndOverridenStructuralFeatures().spliterator(), false)
                    .filter(excludeFieldsFilter().negate())
                    .collect(Collectors.toList());
        } else if (classifier instanceof EEnum) {
            return ((EEnum) classifier).getELiterals();
        }
        return Collections.emptyList();

    }

    /**
     * Первый символ строки сделать заглавным.
     *
     * @param str - входная строка
     * @return измененная строка
     */
    protected String toFirstUpper(String str) {
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

    /**
     * Находит классы с совпадающими simpleName и удаляет дубли.
     * Информация об оставленном классе выводится в warn-логгер.
     * <p/>
     *
     * @param classes перечень классов, в котором нужно удалить дубли
     * @return перечень уникальных по simpleName классов
     */
    protected List<XFWClass> removeDuplicates(List<XFWClass> classes) {
        List<String> duplicatesClassFqn = findDuplicatesClasses(classes);

        removeEmptyClasses(classes, duplicatesClassFqn);

        classes = distinct(classes);

        logger.debug("getEClasses classes: \n{}",
                classes.stream().map(c -> "\n" + c.eClass().getName() + ":" + c.getName() + ":" + c.getInstanceClassName())
                        .collect(Collectors.toList()));

        final List<XFWClass> finalClasses = classes;
        duplicatesClassFqn.forEach(dcn -> {
            final Optional<XFWClass> first = finalClasses.stream()
                    .filter(cl -> cl.getInstanceClassName().equals(dcn)).findFirst();
            if (first.isPresent()) {
                logger.warn("You have two or more classes with identicall simpleName, model.js will contain only {}",
                        first.get().getInstanceClassName());
            }
        });
        return classes;
    }

    /**
     * Метод удаляет пустые классы, созданные для обозначения классов, объевленных в других модулях.
     * Это необходимо, чтобы disctinct далее случайно не удалил полный класс.
     * TODO Нужно от этого избавиться при рефакторинге структуры модели в рамках https://jira.croc.ru/browse/TERRA-354
     * <p/>
     *
     * @param classes            перечень классов, из которых нужно удалить путсые дубликаты
     * @param duplicatesClassFqn перечень FQN дублирующих классов
     */
    private void removeEmptyClasses(List<XFWClass> classes, List<String> duplicatesClassFqn) {
        if (!duplicatesClassFqn.isEmpty()) {
            final List<XFWClass> stubClasses = classes.stream()
                    .filter(c -> duplicatesClassFqn.contains(c.getInstanceClassName()))
                    .collect(Collectors.toList());

            for (final XFWClass stub : stubClasses) {
                if (stub.getEStructuralFeatures().isEmpty()) {
                    classes.remove(stub);
                }
            }
        }
    }

    /**
     * Дедуплецировать классы из списка.
     *
     * @param classes - список классов
     * @return список уникальных классов
     */
    private List<XFWClass> distinct(List<XFWClass> classes) {
        classes = classes.stream()
                .map(Wrap::new)
                .distinct()
                .map(Wrap::unwrap)
                .collect(Collectors.toList());
        return classes;
    }

    /**
     * Найти все продублированные классы в списке и вернуть их FQN.
     *
     * @param classes - список классов
     * @return список FQN не уникальных по simpleName классов
     */
    private List<String> findDuplicatesClasses(List<XFWClass> classes) {
        List<String> duplicatesClassNames = new ArrayList<>();
        List<String> classesNames = classes.stream().map(ENamedElement::getName).collect(Collectors.toList());
        classes.forEach(cl -> {
            final int frequency = Collections.frequency(classesNames, cl.getName());
            if (frequency > 1) {
                duplicatesClassNames.add(cl.getInstanceClassName());
            }
        });
        return duplicatesClassNames;
    }

    private static class Wrap {
        private final XFWClass clazz;

        Wrap(XFWClass clazz) {
            this.clazz = clazz;
        }


        XFWClass unwrap() {
            return clazz;
        }

        @Override
        public int hashCode() {
            return clazz.getName() != null ? clazz.getName().hashCode() : 0;
        }

        @Override
        public boolean equals(Object object) {
            if (this == object) {
                return true;
            }
            if (object == null || getClass() != object.getClass()) {
                return false;
            }

            Wrap that = (Wrap) object;

            return !(clazz != null ? !clazz.getName()
                    .equals(that.clazz.getName())
                    : that.clazz != null);

        }
    }


    protected static void checkFileAutogenerated(File file) {
        if (file.exists()) {
            try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                String line = reader.readLine();
                if (line == null) {
                    return;
                }
                boolean old_style_comment = GENERATED_COMMENT_OLD_STYLE.equals(line.trim());
                if (old_style_comment) {
                    return;
                }
                line = reader.readLine();
                boolean new_style_comment = line!=null && GENERATED_COMMENT_NEW_STYLE.equals(line.trim());
                if (new_style_comment) {
                    return;
                }
                throw new IllegalStateException("File should be deleted before generating: " + file.getPath());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        } else {
            //noinspection ResultOfMethodCallIgnored
            file.getParentFile().mkdirs();
        }

    }
}

